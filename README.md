# CBYYDSDSA2021 实习作业课程报告

## 实习作业简介

本部分为2021春季学期北京大学陈斌老师数据结构与算法课程期末实习作业的简要介绍。

选课同学分为技术组和若干对战组。技术组参与制定游戏规则，调整游戏平衡性，设置游戏地图，编写游戏逻辑，实现可视化程序与循环赛程序。

对战组需要结合课程内容，使用Python语言编写算法。每一个对战组将作为一支参赛队，在对战平台上与其他参赛队伍进行算法对抗。

本次实习作业为“Clash of Ants”类型的对抗性游戏，游戏名称为“星浩哲？（雾）”。本游戏采用不分先后手的回合制，每局游戏由两个玩家参与，回合开始时双方同时提交动作，提交完成后回合内进行结算，而后进行下一回合或结束游戏。

玩家需要扩张势力范围，力争占领对方基地以取得胜利。

## 第一节 游戏基础设置

### 1.1 基础定义

#### 1.1.1 战场，要塞和通路

战场为中心对称或左右对称的有向图，节点和边分别称作“要塞”和“通路”。每个要塞至少与其他另外两个要塞连接。

#### 1.1.2 兵力，移动，战斗

每个要塞具有“归属”和“战力”两个属性。

游戏开始时，双方各占据一个要塞，此要塞称作“基地”，双方基地的初始战力相同。地图上其他要塞内战力为0，归属于中立势力。

双方可以沿通路移动己方要塞的战力至中立、敌方或其他己方要塞。

移动战力至中立要塞可以完成占领；移动至敌方要塞视为向对方占领的要塞发动进攻，根据战斗力判定要塞的归属。被移动的战力会遭受一定损耗，损耗值与通路的属性有关。

在一定范围内，玩家占领的要塞内战力会持续增长；若要塞内战力过高，战力增长会减缓，甚至可能出现负增长。

具体的战斗判定方式、要塞内战力增长方式以及移动战力损耗见1.2。

### 1.2 游戏规则

每个回合按照如下顺序依次进行：

#### 1.2.1 兵力移动

双方提交动作，一个动作是一个长度为三的数组[A, B, C]，A为某个己方要塞，B为目标要塞，C为派出的战力值。

在兵力移动阶段，玩家可以提交多个动作。

合法的动作必须满足三个条件：A是己方要塞；A, B间存在通路；C不大于A处总战力。

#### 1.2.2 兵力更新

A战力减少C，B战力增加C - decay，其中
$$
decay = max(\sqrt{C} + cost,0)
$$
cost为固定损耗，具体数值与A, B间通路的属性有关。地图采取有向图设计，即同一通路两个方向的固定损耗可能不同。

#### 1.2.3 战斗判定

遍历要塞，若某要塞同时存在玩家双方的战力，则进行战斗。

胜者战力剩余
$$
\sqrt{(winnerPower ^ 2 - loserPower ^ 2)}
$$
败者要塞内战力清零。

#### 1.2.4 战斗结算

遍历要塞，判定要塞归属。而后进行要塞内兵力的增长。

具体增长方式采用Logistic增长函数的差分表达，具体计算方法为：
$$
New = x + (powerLimit - x) * x * spawnRate
$$
其中x是当前战力，New表示更新后的战力。

#### 1.2.5 回合结束

当以上4个步骤以此正常完成后，回合结束。

如果某方代码运行错误，或累计运行时间超出最大值，那么后续回合阶段将记为无行动。

#### 1.2.6 胜负判定

若某方基地的兵力为0，游戏结束，占领对方基地的玩家获胜。

如果已完成的回合数达到最大回合数时，游戏结束，占领要塞数量多的玩家获胜。若双方占领要塞数量相等，则所有要塞内总战力高的玩家获胜。若总战力仍然相等，则和局。

若游戏没有结束，则开始新的回合。

## 第二节 对战平台实现说明

### 2.1 地图生成

#### 2.1.1 要塞——地图节点

#### Node.py 的 Node 类

（下面的说明待更改完善，分别注明 Args, Raises, Returns

##### i）类变量

**self.__number**：节点的编号，从1开始

**self.__power**：当前的兵力数列表 [player1, player2]

**self.__belong** ：归属于哪个势力 {-1: 中立, 0:player1 , 1:player2}

**self.__spawn_rate** ：节点产兵的速率, 产兵规则参见GameMap().__natality()

**self.__despawn_rate** ：节点产兵的下降速率

**self.__power_limit**：允许的单个节点无惩罚兵力上限

**self.__nextinfo** ：存储与其他节点的联系 {节点编号: 过路费...}

##### ii）类方法

**（1）**构造函数

 **__ init __：(self, number, spawn_rate=SPAWN_RATE, belong=-1, power_limit=POWER_LIMIT,      despawn_rate=DESPAWN_RATE)**

**（2）**打印节点信息

**__ repr __(*self*)**：在print Node类的一个对象时会输出如下格式的信息

​    -----Node Info:

​    Node number(ID):

​    Node owner:

​    Node power:（player1：,player2：)

​    Node is Connected to:

**（3）**变量访问

**number(self), power(self)·····**

**（4）**变量设定

**set_connection(*self*, *nodeNumber*, *travelCost*)**：设置与当前节点连接的节点，以及之间的过路费

**set_power(*self*, *p*: tuple, *needJudge*: bool)**：用于设置当前节点的战力情况

**（5）**战斗

**combatInNode(*self*)**：当前节点内部进行战斗，战斗规则： 战斗将在一回合内完成并决出胜者，胜者取得当前节点的归属，胜者一方的战力会使用1.2.3中的兰开斯特平方律计算：**calculatePower(*winnerPower*, *loserPower*)**



#### 2.1.2 随机地图生成函数

#### DesignGenerator.py 的 DesignGenerator 类

##### i）类变量

**self.bridge**:

**self.branch:**

**self.depth:**

##### ii）类方法

**（1）**构造函数

**__ init __(*self*, *bridge*: float, *branch*: Tuple[int, int], *depth*: int)**：

**（2）__ call __(*self*)**：用于对类的一个实例对象进行调用



#### 2.1.3 游戏地图

#### GameMap.py 的 GameMap 类

##### i）类变量

**self.xy**:地图字典

**self.nodes:**由 Node 类生成的列表，存储了所有的节点信息

##### ii）类方法

**（1） **构造函数

**__ init __(*self*, *design*: dict)**：

GameMap class的初始化，根据地图字典，生成地图。

nodes存储了地图的所有节点，而具体数据存储在各个node中，详细数据请参见Node class需要主要的是，nodes[0]为无用节点，仅作为占位使用，对于节点的计数从1开始，这是为了与node.number属性保持一致

Args:design (dict): 地图文件中的字典。

**（2）**打印信息

**__ repr __(*self*)**：

**（3）**判断当回合派遣兵力是否合法

**__judge(*self*, *player_actionlist*: list, *tmp_player_id*: int):**

传入参数为玩家当回合所有操作的表，如：[[1,2,5.0],[1,3,4.0],[2,3,6.0]]
若派遣兵力总数大于该节点兵力则引发 RuntimeError。

### 2.2 AI调用方式

#### 2.2.1 GameCore.py

（待补充）

##### AI文件生成指令（若干数组），文件名将传入 Game 类的构造函数

*** __ init __(*self*, *filename1*: str, *filename2*: str, *map_args*: dict):**

filename1 (str): 玩家1的脚本

filename2 (str): 玩家2的脚本目录

map_args (dict): 包含地图配置的字典

#### 

玩家提交的文件为一个python文件，其中应包含`player_class`类。`player_class`类中要包含成员函数`player_func(self, map_info)`与初始化函数`__init__(self, player_id)`。

#### `2.2.2player_func`函数

##### i)综述

`player_func`函数的输入值为变量`map_info`，`map_info`变量为`gamemap`类，负责导入当前局面的地图信息，该函数对当前局面的地图信息进行处理后，返回玩家本回合的动作。`player_func`函数的返回值为一个列表`action`，此列表包含玩家本回合的所有操作。

##### ii)`map_info`变量

`map_info`变量代表当前的地图，其中包含以下分支：

- `map_info.nodes`是一个列表，其中包含了地图的全部节点，每个节点是列表中的一个元素，这个元素为`Node`类，包含以下信息（节点列表中的元素用`node`代替）：
  - `node.number`：节点的编号。游戏开始时，第一个节点属于其中一个玩家，而最后一个节点属于另一个玩家。
  - `node.power`：节点的兵力数。为一个元组`(a,b)`，`a`、`b`分别表示该节点处`player1`与`player2`的兵力数。
  - `node.belong`：节点归属于何势力。为一整数值：值为`-1`代表中立，值为`0`代表归属于`player1`，值为`1`代表归属于`player2`。
  - `node.spawn_rate`和`node.despawn_rate`分别代表节点的产兵速率与节点产兵的下降速率。
  - `node.power_limit`：允许的单个节点无惩罚兵力上限。（具体解释？）
  - `node.nextinfo`：存储节点与其他节点的联系，包括该节点可以通向的节点，以及通向这些节点所需的过路费。
    - 可以用`node.get_next()`获取节点可以通向的节点。返回值是一个列表，列表由该节点可以通向的节点的编号组成。
    - 用`node.get_nextCost(next_)`获取当前节点通向编号为`next_`的节点的过路费。
- `map_info.N`：地图的总节点数。实际上等价于`len(map_info.nodes)`，这样写是为了增加代码的可读性。

每一回合，玩家的程序需要对地图数据进行*适当运算*，并给出自己的操作；下一回合玩家的程序又将输入新的地图，进行新一回合的运算。

##### iii)输出值

玩家对输入的当前局势运算处理后，需要返回一个列表，代表玩家本回合的操作。

列表由若干个元组组成，每个元组代表玩家在该回合进行的单个动作。玩家在游戏中执行的动作无非就是兵力的移动。一次兵力的移动由三起点、终点、移动的兵力数三个量唯一地确定。因此，这个元组也应包含这三个要素。

元组形如`(a,b,c)`。其中：

- `a`代表起始节点，`b`代表目标节点，`a`和`b`都是整数，代表节点的编号。**注意：只能从属于自己的节点出兵；起始节点与终止节点在地图中必须相邻。**
- `c`为移动的兵力数，是一个浮点数。它必须小于等于玩家在起始节点所拥有的兵力数。

#### 2.2.4`player_id`函数

`player_id`是整数，其值为`0`或`1`，表示对战的玩家序号。该函数只需要进行以下处理：将输入值存入`player_class`类的`player_id`分支。

## 第三节 循环赛工具及可视化实现

## 第四节 算法竞赛安排及结果

## 第五节 结语

cb，yyds！